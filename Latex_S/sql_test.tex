\documentclass[a4paper]{article}
\usepackage{CJK}
\usepackage{geometry}
\usepackage{upgreek}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{float}
\usepackage{slashbox}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{threeparttable}
\pagenumbering{Roman}

\definecolor{mygray}{gray}{.9}

\begin{document}
\begin{CJK}{GBK}{hei}
\author{Joe.zhou}
\title{SQL 测试}
\maketitle
%\tableofcontents

\section{实验环境}
\begin{itemize}
  \item 实验服务器
    \begin{itemize}
      \item Master Server :
        \begin{description}
          \item[Name : ] testserver2
          \item[OS : ] CentOS release 5.3 (Final)
          \item[Cpu : ] Intel(R) Pentium(R) 4 CPU 2.26GHz
          \item[Memory : ] 1G
          \item[Ip : ] 10.10.10.132
        \end{description}
      \item Slaver Server :
        \begin{description}
          \item[Name : ] faxtest60
          \item[OS : ] CentOS release 5.3 (Final)
          \item[Cpu : ] Intel(R) Pentium(R) 4 CPU 2.26GHz
          \item[Memory : ] 1G
          \item[Ip : ] 10.10.10.131
        \end{description}
    \end{itemize}
  \item 数据版本
    \begin{description}
      \item[MySQL] : \\
        MySQL Server Community 5.1.52
      \item[PostgreSQL] : \\
        PostgreSQL 9.0.1-1
    \end{description}
  \item 测试程序环境
    \begin{description}
      \item[Python] : \\
        Python 2.4.3
      \item[MySQL] : \\
        MySQL-python-1.2.3
      \item[PostgreSQL] : \\
        PyGreSQL-4.0
    \end{description}
\end{itemize}

\section{性能测试}
性能测试主要手段是利用Python脚本做大数据插入操作。
因为MySQL的MyISAM存储引擎不支持事务安全，所以测试的MySQL数据库引擎选为具有提交，
回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎InnoDB。
性能测试的方面主要是数据的多段查询，插入和修改。
除了插入使用python脚本以外，其它操作都在数据库工具交互模式下测试。两种数据库均没做调优配置。

\begin{table}[H]
\centering
\begin{threeparttable}[b]
\caption{数据插入-I【单位秒】}
\begin{tabularx}{7cm}{Xrr}\hline
\toprule
数据量 & MySQL & PostgreSQL \\ \hline \hline
10000 & 24.524 & 16.990 \\ \hline
\rowcolor{mygray}
100000 & 284.048 & 174.640 \\ \hline
1000000 & 2637.916 & 1743.240 \\ \hline
\rowcolor{mygray}
10000000 & 23005.066 & 17885.873 \\ \hline
\bottomrule
\end{tabularx}
\begin{tablenotes}
\item [备注] 空数据表插入
\end{tablenotes}
\end{threeparttable}
\end{table}

\begin{table}[H]
\centering
\begin{threeparttable}[b]
\caption{数据插入-II【单位秒】}
\begin{tabularx}{7cm}{Xrr}\hline
\toprule
原有数据量 & MySQL & PostgreSQL \\ \hline \hline
10000 & 24.437 & 18.404 \\ \hline
100000 & 25.344 & 17.916 \\ \hline
1000000 & 22.494 & 17.888 \\ \hline
10000000 & 25.630 & 17.938 \\ \hline
\bottomrule
\end{tabularx}
\begin{tablenotes}
\item [备注] 已有数据的表再插入10K数据
\end{tablenotes}
\end{threeparttable}
\end{table}

\begin{table}[H]
\centering
\begin{threeparttable}[b]
\caption{更新字段【单位秒】}
\begin{tabularx}{7cm}{Xrr}\hline
\toprule
数据量 & MySQL & PostgreSQL \\ \hline \hline
10000 & 8.965 & 9.4045 \\ \hline
100000 & 34.670 & 34.1230 \\ \hline
1000000 & 305.594 & 397.5464 \\ \hline
10000000 & 3636.625 & 3536.4815 \\ \hline
\bottomrule
\end{tabularx}
\begin{tablenotes}
\item [备注] SQL语句参见附录A
\end{tablenotes}
\end{threeparttable}
\end{table}

\begin{table}[H]
\centering
\begin{threeparttable}[b]
\caption{多段查询统计【单位秒】}
\begin{tabularx}{7cm}{Xrr}\hline
\toprule
数据量 & MySQL & PostgreSQL \\ \hline \hline
10000 & 0 & 0.3 \\ \hline
100000 & 0.37 & 3.817 \\ \hline
1000000 & 0.47 & 32.617 \\ \hline
10000000 & 0 & 263.844 \\ \hline
\bottomrule
\end{tabularx}
\end{threeparttable}
\end{table}

\begin{table}[H]
\centering
\begin{threeparttable}[b]
\caption{创建索引【单位秒】}
\begin{tabularx}{7cm}{Xrr}\hline
\toprule
数据量 & MySQL & PostgreSQL \\ \hline \hline
10000 & 4 & 0.068 \\ \hline
100000 & 31.73 & 1.382767 \\ \hline
1000000 & 287 & 66.22473 \\ \hline
10000000 & 3201 & 725.110792 \\ \hline
\bottomrule
\end{tabularx}
\begin{tablenotes}
\item [备注] SQL语句参见附录A
\end{tablenotes}
\end{threeparttable}
\end{table}

\begin{table}[H]
\centering
\begin{threeparttable}[b]
\caption{修改表段【单位秒】}
\begin{tabularx}{7cm}{Xrr}\hline
\toprule
数据量 & MySQL & PostgreSQL \\ \hline \hline
10000 & 4 & \multicolumn{1}{c}{\multirow{4}*{0.001s}} \\ \cline{1-2}
100000 & 31.73 & \multicolumn{1}{c}{} \\ \cline{1-2}
1000000 & 279 & \multicolumn{1}{c}{} \\ \cline{1-2}
10000000 & 2960 & \multicolumn{1}{c}{} \\ \cline{1-3}
\bottomrule
\end{tabularx}
\begin{tablenotes}
\item [备注] SQL语句参见附录A
\end{tablenotes}
\end{threeparttable}
\end{table}

从以上图表可以看出PostgreSQL在数据插入修改方面性能要优于MySQL.多段查询中MySQL的查询速度比PostgreSQL快,字段更新两者性能差不多。


\section{同步测试}

\subsection{DML操作同步}

\begin{table}[H]
\begin{center}
\caption{DML操作同步}
\begin{tabular}{c c c c c}\hline \toprule
\multicolumn{2}{c}{\multirow{2}*{操作}} &\multicolumn{2}{c}{MySQL} & PostgreSQL \\ \cline{3-5}
\multicolumn{2}{c}{}                    & RBR & MBR & - \\ \hline \hline
\multicolumn{1}{c}{\multirow{3}*{带索引表}} & 增加记录 & ${\surd}$ & ${\surd}$ & - \\ \cline{2-5}
\multicolumn{1}{c}{}                        & 修改记录 & ${\surd}$ & ${\surd}$ & - \\ \cline{2-5}
\multicolumn{1}{c}{}                        & 删除记录 & ${\surd}$ & ${\surd}$ & - \\ \hline \hline

\multicolumn{1}{c}{\multirow{3}*{无索引表}} & 增加记录 & ${\surd}$ & ${\surd}$ & - \\ \cline{2-5}
\multicolumn{1}{c}{}                        & 修改记录 & ${\surd}$ & ${\surd}$ & - \\ \cline{2-5}
\multicolumn{1}{c}{}                        & 删除记录 & ${\surd}$ & ${\surd}$ & - \\ \hline
\bottomrule
\end{tabular}
\end{center}
\end{table}

\subsection{DDL操作同步}

\begin{table}[H]
\begin{center}
\caption{DDL操作同步}
%\begin{tabular}{c c c c}\hline
\begin{tabularx}{8cm}{Xccc}\hline
\toprule
\multicolumn{1}{l}{\multirow{2}*{操作}} &\multicolumn{2}{c}{MySQL} & PostgreSQL \\ \cline{2-4}
\multicolumn{1}{l}{}                    & RBR & MBR & - \\ \hline \hline
增加表     & ${\surd}$ & ${\surd}$ & - \\ \hline
删除表     & ${\surd}$ & ${\surd}$ & - \\ \hline
修改表名   & ${\surd}$ & ${\surd}$ & - \\ \hline
修改表字段 & ${\surd}$ & ${\surd}$ & - \\ \hline
增加表索引 & ${\surd}$ & ${\surd}$ & - \\ \hline
删除表索引 & ${\surd}$ & ${\surd}$ & - \\ \hline
修改表索引 & ${\surd}$ & ${\surd}$ & - \\ \hline
\bottomrule
\end{tabularx}
\end{center}
\end{table}

两者在 DML和DDL同步测试中基本都能做到各种操作数据同步。

\section{异常测试}

\begin{itemize}
  \item MySQL
    \begin{enumerate}
      \item 100个线程同时执行select,insert,update,delete四种操作，
          每种循环100次，执行过程中kill掉Master server 的MySQL服务器进程后，重新启动MySQL服务进程，
          过一段时间后同步恢复正常。
      \item Master server 做插入操作时，kill掉Slave server 的MySQL服务器进程后，重新启动MySQL服务进程，
          过一段时间后同步恢复正常。
    \end{enumerate}
  \item PostgreSQL
\end{itemize}

\section{灾难恢复，主从恢复}

\begin{itemize}
  \item MySQL
  \begin{itemize}
      \item Master Server 服务器宕机时使用以下步骤来Failover
      \begin{enumerate}
      \item 关闭Master Server
      \item 检查Slave Server状态，确定已经同步所有数据后
      \begin{verbatim}
mysql> SHOW PROCESSLIST;
  State: Has read all relay log;
    waiting for the slave I/O thread to update it
      \end{verbatim}
      \item 停止Slave Server 的slave 线程，并reset为Master Server
      \begin{verbatim}
mysql> STOP SLAVE;
mysql> REST MASTER;
      \end{verbatim}
      \item 将原Master Server维护好后，设置为Slave Server,配置同步新的Master Server
      \begin{verbatim}
mysql> STOP SLAVE;
mysql> CHANGE MASTER TO
        MASTER_HOST='10.10.10.131',
        MASTER_USER='backup',
        MASTER_PASSWORD='123456';
mysql> START SLAVE;
      \end{verbatim}
      \item 检查新slave server状态
      \begin{verbatim}
mysql> SHOW SLAVE STATUS\G;
      \end{verbatim}
      \end{enumerate}

      \item 当同步出错，出现数据不一致时使用以下代码来跳过N个错误事件。
      \begin{verbatim}
mysql> STOP SLAVE;
mysql> SET GLOBAL SQL_SLAVE_SKIP_COUNTER=N;
mysql> START SLAVE;
      \end{verbatim}
      当错误事件较多时，可在Master server运行
      \begin{verbatim}
mysql> RESET MASTER;
      \end{verbatim}
      在Slave server运行
      \begin{verbatim}
mysql> STOP SLAVE;
mysql> RESET SLAVE;
mysql> START SLAVE;
      \end{verbatim}
      来清除志同步位置标志，并重新生成master.info，但是这样以前没同步的事件将忽略，需手动同步。
  \end{itemize}

  \item PostgreSQL

\end{itemize}

\newpage
\appendix
\section{附录}
\begin{itemize}
  \item 测试数据库表结构

\begin{verbatim}
CREATE TABLE IF NOT EXISTS `tbl_fax_records` (
  `faxid` varchar(50) NOT NULL DEFAULT '',
  `taskid` varchar(50) DEFAULT NULL,
  `fax_serv_addr` varchar(30) DEFAULT NULL,
  `userid` varchar(20) DEFAULT NULL,
  `receiver_number` varchar(30) DEFAULT NULL,
  `status` tinyint(4) NOT NULL,
  `fee` decimal(10,3) DEFAULT NULL,
  `time_long` smallint(6) DEFAULT NULL,
  `npages` smallint(6) DEFAULT NULL,
  `error` int(11) DEFAULT NULL,
  `error_descr` varchar(250) DEFAULT NULL,
  `read_count` smallint(6) DEFAULT NULL,
  `fax_start_date` datetime DEFAULT NULL,
  `fax_end_date` datetime DEFAULT NULL,
  `create_date` datetime DEFAULT NULL,
  `jobid` varchar(15) DEFAULT NULL,
  `actual_fee` decimal(10,3) DEFAULT NULL,
  `sip_descr` varchar(200) DEFAULT NULL,
  `submit_date` datetime DEFAULT NULL,
  `kill_date` datetime DEFAULT NULL,
  `ext_delay` tinyint(4) NOT NULL DEFAULT '3',
  `priority` tinyint(4) NOT NULL DEFAULT '1',
  `fax_type` tinyint(4) NOT NULL,
  `ts_type` tinyint(4) NOT NULL DEFAULT '0',
  `origin_error` int(11) DEFAULT NULL,
  `retries` tinyint(4) NOT NULL DEFAULT '0',
  `max_retries` tinyint(4) NOT NULL DEFAULT '2',
  `fax_res` tinyint(4) DEFAULT NULL,
  `fax_dcs` varchar(16) DEFAULT NULL,
  `send_rate` tinyint(4) DEFAULT NULL,
  `send_res` tinyint(4) DEFAULT NULL,
  `send_2D` tinyint(4) DEFAULT NULL,
  `send_ecm` tinyint(4) DEFAULT NULL,
  `retry_type` tinyint(4) NOT NULL DEFAULT '0',
  `recipient` varchar(30) DEFAULT NULL,
  `recipient_company` varchar(100) DEFAULT NULL,
  `area` varchar(5) DEFAULT NULL,
  `number_type` tinyint(4) DEFAULT NULL,
  `hold_times` int(11) DEFAULT NULL,
  PRIMARY KEY (`faxid`),
  KEY `fax_record_taskid` (`taskid`),
  KEY `idx_priority` (`priority`),
  KEY `idx_create_date` (`create_date`),
  KEY `idx_addr` (`fax_serv_addr`),
  KEY `idx_start_date` (`fax_start_date`),
  KEY `idx_kill_date` (`kill_date`),
  KEY `idx_status` (`status`),
  KEY `idx_error` (`error`),
  KEY `idx_fax_type` (`fax_type`),
  KEY `idx_user` (`userid`),
  KEY `idx_number` (`receiver_number`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
\end{verbatim}

\begin{verbatim}
CREATE TABLE tbl_fax_records (
  faxid varchar(50) NOT NULL DEFAULT '',
  taskid varchar(50) DEFAULT NULL,
  fax_serv_addr varchar(30) DEFAULT NULL,
  userid varchar(20) DEFAULT NULL,
  receiver_number varchar(30) DEFAULT NULL,
  status integer NOT NULL,
  fee decimal(10,3) DEFAULT NULL,
  time_long smallint DEFAULT NULL,
  npages smallint DEFAULT NULL,
  error int DEFAULT NULL,
  error_descr varchar(250) DEFAULT NULL,
  read_count smallint DEFAULT NULL,
  fax_start_date timestamp DEFAULT NULL,
  fax_end_date timestamp DEFAULT NULL,
  create_date timestamp DEFAULT NULL,
  jobid varchar(15) DEFAULT NULL,
  actual_fee decimal(10,3) DEFAULT NULL,
  sip_descr varchar(200) DEFAULT NULL,
  submit_date timestamp DEFAULT NULL,
  kill_date timestamp DEFAULT NULL,
  ext_delay integer NOT NULL DEFAULT '3',
  priority integer NOT NULL DEFAULT '1',
  fax_type integer NOT NULL,
  ts_type integer NOT NULL DEFAULT '0',
  origin_error int DEFAULT NULL,
  retries integer NOT NULL DEFAULT '0',
  max_retries integer NOT NULL DEFAULT '2',
  fax_res integer DEFAULT NULL,
  fax_dcs varchar(16) DEFAULT NULL,
  send_rate integer DEFAULT NULL,
  send_res integer DEFAULT NULL,
  send_2D integer DEFAULT NULL,
  send_ecm integer DEFAULT NULL,
  retry_type integer NOT NULL DEFAULT '0',
  recipient varchar(30) DEFAULT NULL,
  recipient_company varchar(100) DEFAULT NULL,
  area varchar(5) DEFAULT NULL,
  number_type integer DEFAULT NULL,
  hold_times int DEFAULT NULL,
  PRIMARY KEY (faxid,taskid,priority,create_date,
  fax_serv_addr,fax_start_date,kill_date,
  status,error,fax_type,userid,receiver_number)
) ;
\end{verbatim}


\item 记录插入SQL语句(python)

\begin{verbatim}
"""INSERT INTO tbl_fax_records (
faxid , taskid , fax_serv_addr , userid , receiver_number ,
status , fee , time_long , npages , error ,
error_descr , read_count , fax_start_date , fax_end_date , create_date ,
jobid , actual_fee , sip_descr , submit_date , kill_date ,
ext_delay , priority , fax_type , ts_type , origin_error ,
retries , max_retries , fax_res , fax_dcs , send_rate ,
send_res , send_2D , send_ecm , retry_type , recipient ,
recipient_company , area , number_type , hold_times) VALUES(
'%s', '%s', '', '%s', '079733445566',
3, 0.000, 0, 1, 13,
NULL, 0, '%s', NULL, '%s',
NULL, 0.000, NULL, '%s','%s',
3, 105, 1, 0, NULL,
0, 3, 0, NULL, NULL,
0, 0, 0, 0, 0,
'dfd', '0797', 0,0);"""
%
(2100000207231448050 + index_i,
2100000000000000050 + index_i,
21000004 + index_i,
time.strftime('%Y-%m-%d %H:%M:%S',time.localtime()),
time.strftime('%Y-%m-%d %H:%M:%S',time.localtime()),
time.strftime('%Y-%m-%d %H:%M:%S',time.localtime()),
time.strftime('%Y-%m-%d %H:%M:%S',time.localtime()),)
\end{verbatim}

\item 多段查询SQL语句

\begin{verbatim}
select count(*) from tbl_fax_records
    where status = 3 and
        receiver_number = '079733445566' and
        faxid like '40000002072314480%';

select faxid,userid,send_2D,retry_type from tbl_fax_records
    where status = 3 and
        receiver_number = '079733445566' and
        faxid like '40000002072314480%';
\end{verbatim}

\item 更新表段SQL语句

\begin{verbatim}
update tbl_fax_records set fax_serv_addr = 'localhostOOXX123456789';
\end{verbatim}

\item 修改表段SQL语句

\begin{verbatim}
alter table tbl_fax_records add x  smallint(4);
\end{verbatim}

\item 创建索引SQL语句

\begin{verbatim}
create index index_ids on tbl_fax_records(faxid,taskid);
\end{verbatim}

\begin{table}[H]
\begin{center}
\caption{性能测试}
\begin{tabular}{|p{6cm}|p{3cm}|p{3cm}|}\hline
\backslashbox{\kern+6em 操作}{\kern+6em 用时} & \hfil MySQL & \hfil PostgreSQL \\ \hline

单线程插入20000000条记录 & & \\ \hline
随机查询 & & \\ \hline
随机修改 & & \\ \hline
随机删除 & & \\ \hline
多字段查询 & & \\ \hline
带索引随机查询 & & \\ \hline
带索引多段查询 & & \\ \hline
100个线程同时插入200000条记录 & & \\ \hline
\end{tabular}
\end{center}
\end{table}

\end{itemize}

\end{CJK}
\end{document} 